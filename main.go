package main

import (
	"fmt"
	"math"
	"os"
	"strconv"
	"strings"

	ini "github.com/gookit/ini"
	colorful "github.com/lucasb-eyer/go-colorful"
)

// named color with values for lightness, chroma and hue
type nc struct {
	name string
	li   float64
	ch   float64
	hu   float64
}

var (
	// define a slice of structs containig main hues
	clrs = []nc{
		{"red", 0.0, 1.0, 0.5},
		{"orange", 0.0, 1.0, 0.5},
		{"yellow", 0.0, 1.0, 0.5},
		{"lime", 0.0, 1.0, 0.5},
		{"green", 0.0, 1.0, 0.5},
		{"cyan", 0.0, 1.0, 0.5},
		{"blue", 0.0, 1.0, 0.5},
		{"indigo", 0.0, 1.0, 0.5},
		{"purple", 0.0, 1.0, 0.5},
		{"pink", 0.0, 1.0, 0.5},
		{"grey", 0.0, 1.0, 0.5},
	}

	variants     = []nc{}
	darkVariants = []nc{}
)

func main() {

	// Load configuration from file
	config, err := ini.LoadExists("palegen.ini")
	if err != nil {
		fmt.Printf("Error: %v\n", err)
	}

	// Read base colour from config
	var inputFormat string
	var ic colorful.Color

	base, ok := config.String("hex")
	if ok {
		inputFormat = "hex"
	}

	baseRgb, ok := config.String("rgb")
	if ok {
		inputFormat = "rgb"
	}

	baseLch, ok := config.String("lch")
	if ok {
		inputFormat = "lch"
	}

	fmt.Println("inputFormat:", inputFormat)

	switch inputFormat {
	case "hex":
		var err error
		fmt.Println("Base color found:", base)
		ic, err = colorful.Hex(base)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		}
		fmt.Println("Input color set: hex", ic)
	case "rgb":
		unspaced := strings.ReplaceAll(baseRgb, " ", "")
		values := strings.Split(unspaced, ",")
		r, err := strconv.ParseFloat(values[0], 64)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		}
		g, err := strconv.ParseFloat(values[1], 64)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		}
		b, err := strconv.ParseFloat(values[2], 64)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		}
		ic = colorful.Color{(r / 100), (g / 100), (b / 100)}
		fmt.Println("Input color set: RGB", ic)
	case "lch":
		unspaced := strings.ReplaceAll(baseLch, " ", "")
		values := strings.Split(unspaced, ",")
		l, err := strconv.ParseFloat(values[0], 64)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		}
		c, err := strconv.ParseFloat(values[1], 64)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		}
		h, err := strconv.ParseFloat(values[2], 64)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		}
		fmt.Println("Input lch() values:", l, c, h)
		ic = colorful.Hcl(h, (c / 100), (l / 100))
	}

	// For testing
	fmt.Println("Input color now:", ic)

	// Input colour converted to Hcl space (hue, chroma, luminosity)
	h, c, l := ic.Hcl()

	fmt.Println("Converted to HCL space:", h, c, l)

	// generate colors
	rotateHue(h, c, l)

	//generate a grey tinted with input (base) color
	grey(h, c, l)

	// generate lightness variants of each hue
	genVariants(h, c, l)

	// generate dark mode variants of each hue
	genDarkVariants(h, c, l)

	// Output file with clrs as css vars
	// Get output destination
	outputFile, ok := config.String("outputFile")
	if !ok {
		outputFile = "colors.css"
	}
	// Open outputFile for writing
	if f, err := os.Create(outputFile); err != nil {
		fmt.Printf("Error creating file: %v\n", err)
	} else {
		// defers close file to when function finishes running
		defer f.Close()

		// start root section of css
		if _, err = f.WriteString(`:root {
/* Generated by palegen */
`); err != nil {
			fmt.Printf("Error: %v\n", err)
		}

		// Write the input base color directly as css vars
		// base as hsla
		h, s, l := ic.Clamped().Hsl()
		_, err = fmt.Fprintf(f, "  --base: hsla(%.2f, %.2f%%, %.2f%%, 1);\n", h, float64(s*100), float64(l*100))
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		}

		// convert clrs slice to CSS output as css vars
		for i := range clrs {
			h, s, l := colorful.Hcl(clrs[i].hu, clrs[i].ch, clrs[i].li).HSLuv()
			_, err = fmt.Fprintf(f, "  --%s: hsla(%.2f, %.2f%%, %.2f%%, 1);\n", clrs[i].name, h, float64(s*100), float64(l*100))
			if err != nil {
				fmt.Printf("Error: %v\n", err)
			}
		}

		// empty in css
		_, err = fmt.Fprintf(f, "\n")
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		}

		// Directly Add a black tinted to background via alpha
		_, err = f.WriteString("  --textblack: hsla(0, 100%, 0%, 0.9);\n")
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		}

		// Directly Add a white tinted to background via alpha
		_, err = f.WriteString("  --textwhite: hsla(360, 100%, 100%, 0.9);\n")
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		}

		// empty line
		_, err = f.WriteString("\n")
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		}

		// Print lightness variants as CSS
		for i := range variants {
			h, s, l := colorful.Hcl(variants[i].hu, variants[i].ch, variants[i].li).HSLuv()
			_, err = fmt.Fprintf(f, "  --%s: hsla(%.2f, %.2f%%, %.2f%%, 1);\n", variants[i].name, h, float64(s*100), float64(l*100))
			if err != nil {
				fmt.Printf("Error: %v\n", err)
			}
		}

		// end root section of css
		_, err = f.WriteString("\n}")
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		}

		// empty line
		_, err = f.WriteString("\n")
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		}

		// Open preferes-color-scheme dark media query and nested root section
		_, err = f.WriteString(`
@media (prefers-color-scheme: dark) {
  :root {
`)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		}

		// Flip the color tinted text black to white in darkmode
		_, err = f.WriteString("    --textwhite: hsla(0, 100%, 0%, 0.9);\n")
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		}

		// Flip the color tinted text white to black in darkmode
		_, err = f.WriteString("    --textblack: hsla(360, 100%, 100%, 0.9);\n")
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		}

		// empty line
		_, err = f.WriteString("\n")
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		}

		for i := range darkVariants {
			h, s, l := colorful.Hcl(darkVariants[i].hu, darkVariants[i].ch, darkVariants[i].li).HSLuv()
			_, err = fmt.Fprintf(f, "    --%s: hsla(%.2f, %.2f%%, %.2f%%, 1);\n", darkVariants[i].name, h, float64(s*100), float64(l*100))
			if err != nil {
				fmt.Printf("Error: %v\n", err)
			}
		}

		// end nested dark mode root section of css
		_, err = f.WriteString(`  }
}`)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		}

		fmt.Println("Color generation complete.")
	}
}

func rotateHue(h float64, c float64, l float64) []nc {

	// rotate the hue value around the full 360 degress with 10 steps
	steps := 10
	hueStep := float64(360 / steps)

	for i := 0; i < steps; i++ {

		h := math.Mod(((float64(i) * hueStep) + h), 360)

		switch {
		case h >= 0 && h <= 12:
			for i := range clrs {
				if clrs[i].name == "red" {
					clrs[i].li = l
					clrs[i].ch = c
					clrs[i].hu = math.Floor(h)
				}
			}
		case h >= 12 && h <= 48:
			for i := range clrs {
				if clrs[i].name == "orange" {
					clrs[i].li = l
					clrs[i].ch = c
					clrs[i].hu = math.Floor(h)
				}
			}
		case h > 48 && h <= 84:
			for i := range clrs {
				if clrs[i].name == "yellow" {
					clrs[i].li = l
					clrs[i].ch = c
					clrs[i].hu = math.Floor(h)
				}
			}
		case h > 84 && h <= 120:
			for i := range clrs {
				if clrs[i].name == "lime" {
					clrs[i].li = l
					clrs[i].ch = c
					clrs[i].hu = math.Floor(h)
				}
			}
		case h > 120 && h <= 156:
			for i := range clrs {
				if clrs[i].name == "green" {
					clrs[i].li = l
					clrs[i].ch = c
					clrs[i].hu = math.Floor(h)
				}
			}
		case h > 156 && h <= 192:
			for i := range clrs {
				if clrs[i].name == "cyan" {
					clrs[i].li = l
					clrs[i].ch = c
					clrs[i].hu = math.Floor(h)
				}
			}
		case h > 192 && h <= 228:
			for i := range clrs {
				if clrs[i].name == "blue" {
					clrs[i].li = l
					clrs[i].ch = c
					clrs[i].hu = math.Floor(h)
				}
			}
		case h > 228 && h <= 264:
			for i := range clrs {
				if clrs[i].name == "indigo" {
					clrs[i].li = l
					clrs[i].ch = c
					clrs[i].hu = math.Floor(h)
				}
			}
		case h > 264 && h <= 300:
			for i := range clrs {
				if clrs[i].name == "purple" {
					clrs[i].li = l
					clrs[i].ch = c
					clrs[i].hu = math.Floor(h)
				}
			}
		case h > 300 && h <= 336:
			for i := range clrs {
				if clrs[i].name == "pink" {
					clrs[i].li = l
					clrs[i].ch = c
					clrs[i].hu = math.Floor(h)
				}
			}
		case h > 336 && h <= 360:
			for i := range clrs {
				if clrs[i].name == "red" {
					clrs[i].li = l
					clrs[i].ch = c
					clrs[i].hu = math.Floor(h)
				}
			}
		}
	}
	return clrs
}

func grey(h float64, c float64, l float64) []nc {

	// Doesn't need a seperate var at this point but I may make this
	// configurable evenutally
	nc := 0.05

	for i := range clrs {
		if clrs[i].name == "grey" {
			clrs[i].li = 0.5
			clrs[i].ch = nc
			clrs[i].hu = math.Floor(h)
		}
	}
	return clrs
}

func genVariants(h float64, c float64, l float64) []nc {

	// step through fixed lightness values
	lightness := [8]float64{0.98, 0.9, 0.79, 0.66, 0.46, 0.32, 0.2, 0.1}

	for x := range clrs {
		for i := 0; i < len(lightness); i++ {
			nnc := new(nc)
			nnc.name = clrs[x].name + strconv.Itoa(i)
			nnc.li = lightness[i]
			nnc.ch = clrs[x].ch
			nnc.hu = clrs[x].hu
			variants = append(variants, *nnc)
		}
	}
	return variants
}

func genDarkVariants(h float64, c float64, l float64) []nc {
	// step through fixed lightness values
	darkness := [8]float64{0.1, 0.2, 0.32, 0.46, 0.66, 0.79, 0.9, 0.98}

	for x := range clrs {
		for i := 0; i < len(darkness); i++ {
			nnc := new(nc)
			nnc.name = clrs[x].name + strconv.Itoa(i)
			nnc.li = darkness[i]
			nnc.ch = clrs[x].ch
			nnc.hu = clrs[x].hu
			darkVariants = append(darkVariants, *nnc)
		}
	}
	return darkVariants
}
